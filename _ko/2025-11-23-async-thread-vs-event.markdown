---
title: 비동기를 처리하는 두 가지 방식 - 스레드와 이벤트
lang: ko
layout: post
---

## 들어가며

- 이 글은 비동기 처리를 다루는 두 방식인 스레드 기반 방식과 이벤트 루프 기반 방식이 가지는 차이를 다룬다.
- 최종 수정일: 25/11/24

업무에서 FastAPI를 사용하게 되면서 Python의 async/await 기반 이벤트 루프 모델을 경험하게 되었고, 이전에 경험한 Spring MVC 기반의 Thread Pool + CompletableFuture 기반 비동기 처리와 비교할 기회가 생겼다.

Spring MVC는 Thread-Per-Request + Blocking I/O 구조를 사용하기 때문에, 비동기 처리도 본질적으로 스레드 기반 병렬성을 벗어나지 못한다. 요청은 워커 스레드 1개에서 동기적으로 실행되고, JDBC 역시 기본적으로 Blocking I/O 방식이다. 따라서 컨테이너를 Tomcat 대신 Netty로 교체하거나, Spring WebFlux + R2DBC 같은 완전한 non-blocking 스택을 사용하지 않는 다면 비동기의 효과는 결국 스레드를 다른 풀로 분산시키는 수준이라고 이해하고 있다.

반면, FastAPI에서는 async/await 기반 이벤트 루프 비동기 모델을 표면적으로는 쉽게 사용할 수 있지만, 아직 내부 동작 방식은 완전히 이해하지 못했다. 처음에는 psycopg2 같은 blocking DB 드라이버로 구현했으나, 이후 asyncpg로 바꾸어 non-blocking I/O 환경도 직접 경험해보았다.

이 글에서는 FastAPI가 이용하는 이벤트 루프 기반 비동기가 Spring MVC가 이용하는 스레드 기반 비동기와 실제로 어떤 차이가 있는지, 특히 I/O 중심 작업에서의 차이를 더 깊이 살펴보고 비교하고자 한다. 이 과정에서 기본적인 비동기 모델의 차이와 함께, 프레임워크가 가지는 차이도 부수적으로 살펴보고자 한다.

## 비동기 이해하기

### 개념

비동기 프로그래밍은 하나의 작업이 완료되기를 기다리지 않고, 다음 작업을 이어서 실행할 수 있도록 하는 프로그래밍 모델이다. 비동기 프로그래밍에서는 제어 흐름이 비선형적이고, 특정 작업의 완료를 기다리는 동안 스레드가 블로킹되지 않는다. 비동기 모델이 동기 모델과 어떤 차이가 있는지 살펴보면 더욱 이해가 쉽다.

- 제어 흐름의 분리

비동기 모델에서는 작업의 시작과 결과의 처리가 분리되는 것이 특징이다. 동기 모델에서 함수의 호출과 반환이 스택에 쌓인다면, 비동기 모델에서는 작업 지시 후 제어권이 호출부에 반환된다. 이러한 결과는 완료 시점에 비동기 처리 메커니즘을 통해 다루어진다.

- 논블로킹 I/O

동기 모델에서의 I/O 작업이 이루어지면 호출부의 스레드가 대기 상태에 들어간다. 이를 블로킹 I/O라고 부를 수 있다. 반면, 비동기 모델에서는 I/O 작업을 위임하고 바로 제어권을 반환 받는다. 이를 논블로킹 I/O라고 할 수 있다.

비동기 모델이 논블로킹 I/O를 특징으로 가지지만, 기술적으로 논블로킹 I/O 자체가 비동기는 아님에 유의해야한다. 오히려 논블로킹 I/O가 제어 흐름의 분리를 위해서 채택되었다고 보는 것이 더 명확하다. 비동기 처리는 완료 시점에서의 처리 메커니즘까지 포함되는 개념이라고 보면 쉽다.

### 필요성

비동기 모델의 필요성을 떠올리기 위해서 비동기 모델이 존재하지 않을 때를 상상해보면 좋을 것 같다. 모든 요청이 동기적으로 처리된다면 어떨까? 특히 값비싼 I/O 요청이라면? 놀랍게도 세상에는 이미 C10K 문제라는 것이 존재했다.

- C10K 문제

C10K 문제는 1999년 댄 케겔(Dan Kegel)이 제시한 문제로, 다음과 같은 뜻을 가진다. 1만(10k)개의 동시(Concurrent) 클라이언트(Client)를 어떻게 효율적으로 처리할 것인가? 당시에 우세했던 Thread-Per-Request 방식으로는 이러한 문제를 풀기가 어려웠다. 어떤 문제가 생길까?

친절하게도 ![올리브영 테크블로그 - 고전 돌아보기, C10K 문제](https://oliveyoung.tech/2023-10-02/c10-problem/)에서 "1만 명이 접속하는 채팅 서버"라는 예시로 c10k 문제를 다루어주었으니, 간략하게만 설명하고 넘어가고자 한다.

> Thread가 1만개가 실행되면 어떤 문제가 있을까요?

> 먼저, 메모리가 문제가 됩니다. thread가 하나 생성되면, 각 thread는 별도의 메모리 스택을 가지게 됩니다.
> 물론 process보다는 적지만, Java 64bit VM의 경우 1개의 thread는 1024kbyte(1MB)를 사용한다고 합니다.
> 1만명이면 10Gbyte 정도가 기본으로 필요하겠네요? 괜찮습니다. 이 정도는 버틸만 합니다. 우리 서버는 64Gbyte 메모리를 가지고 있거든요.

첫째, 각 스레드 당 스택 사용량으로 인한 메모리 오버헤드가 발생한다.

> (아직도 뒷골이 서늘합니다.) 잘 알고 있다시피, thread를 너무 많이 만들면 context switching 과정에서 경합(racing condition)이 발생합니다.
> 각 thread가 자신의 execution time을 할당 받기 위해서 서로 경쟁을 하지요.
> 소켓에 데이터가 들어왔는지 확인하고 읽어들이기 위해서 1만개의 thread는 모두 polling 경쟁을 벌이게 됩니다.
> 아무도 채팅창에서 키보드를 치고 있지 않지만, 제가 만든 서버의 thread는 서로 CPU 자원을 차지하기 위해서 아우성을 지릅니다.

둘째, 스레드 간의 CPU 자원 경쟁과 컨텍스트 스위칭 과정에서의 경쟁이 발생한다.

이제 다시 이번 글의 '개념' 파트를 돌아보자. 비동기 모델에서는 작업의 시작과 결과의 분리가 이루어진다. '논블로킹 I/O'로 1만 개의 대기 스레드를 없애 물리적 자원 문제(스레드 폭발)를 해결하고, '제어 흐름의 분리'가 단일 스레드로 1만 개의 독립적인 작업 흐름을 관리해 논리적 동시성 문제(요청 구분)를 해결하면 어떨까?

이것이 바로 대기가 긴 I/O 바운드 작업에서 비동기가 필요한 이유다. 하지만 반대로 말하자면, CPU 바운드 작업에서는 비동기가 필요하지 않다는 뜻이기도 하다. CPU 바운드 작업에서는 대기보다는 연산이 우위를 점하기 때문이다.

### 모델 비교: 스레드 vs. 이벤트 루프

#### 이벤트 루프 모델

앞서 말했듯, 비동기 처리를 통해 단일 스레드로도 C10K 문제에 대응할 수 있다고 치자. 그렇다면 어떻게 스레드를 1만 개나 만들지 않고도 1만 개의 요청을 구분하면서 작업 흐름을 관리할 것인가?

이벤트 루프(Event Loop)라는 대표적인 비동기 모델이 있다. 이름에서 잘 드러나듯이, 이벤트 루프는 종료되기 전까지 계속 "반복"해 "이벤트" 메시지를 수신하고 처리한다. 여기서 이벤트 메시지는 C10K 문제에서의 각 요청의 완료 신호로 대응할 수 있다. 의사 코드는 다음과 같다.

```
loop
    message := get_next_message()
    process_message(message)
while message != quit
```

적은 수의 스레드가 위와 같이 이벤트 루프를 통해 요청을 관리한다. 하지만 이벤트 루프가 CPU-heavy한 연산으로 블로킹되면 전체 요청 처리 속도가 급격히 떨어진다. 따라서 이벤트 루프 기반 시스템에서는 I/O 작업은 커널 레벨의 논블로킹 이벤트 큐를 통해 수행하고, CPU-heavy 작업은 별도 워커 스레드 풀에서 처리하는 경우가 많다.

#### 스레드 기반 모델

스레드 기반 모델(Thread-Per-Request 방식)이라고 해서 비동기 처리를 전혀 사용할 수 없는 것은 아니다. 스레드 기반 모델에서도 나중에 결과를 받을 수 있는 객체를 이용하면 비동기적으로 작업 결과를 처리할 수 있기 때문이다. 예를 들어, Java의 Future, Rust의 Task, JavaScript의 Promise 등이 있다.

즉, 작업 완료를 기다리는 동안 호출 측 코드가 블로킹되지 않아 다른 작업을 진행할 수 있다. 그러나 물리적 스레드 자체는 요청 수만큼 존재하기 때문에, I/O가 많은 환경에서는 스레드 폭발 문제가 여전히 발생할 수 있다.

다만 매번 스레드를 새로 생성하는 것은 아니며, 스레드 풀을 사용해 이미 생성된 유휴 스레드를 재사용하는 경우가 많다. 예를 들어, 스레드 풀 기반의 비동기 실행을 지원하여 스레드 관리 비용을 줄일 수 있다.

#### 하이브리드 모델

이벤트 루프 모델이 I/O-bound 작업에서 효율적인 것처럼, 스레드 기반 모델은 CPU-heavy 작업을 병렬로 처리할 수 있다는 장점이 있다. 이는 곧 서로의 단점을 상쇄함을 의미한다.

따라서 현대 서버는 두 모델을 결합하는 하이브리드 구조를 많이 사용한다. I/O 처리는 이벤트 루프에서 논블로킹 I/O로 처리해 수만 개 요청을 동시에 처리하고,
CPU-heavy 연은 별도 워커 스레드 풀에서 병렬 처리해 이벤트 루프의 블로킹을 방지하고 연산 성능을 높인다.

## 사례로 보는 비동기 처리

### Spring MVC

### FastAPI

## 사고 실험: 스레드 vs. 이벤트 루프

## 더 나아가기

## References

https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/
https://github.com/python/cpython/blob/e457d60daafe66534283e0f79c81517634408e57/InternalDocs/asyncio.md#L4

https://oliveyoung.tech/2023-10-02/c10-problem/

https://en.wikipedia.org/wiki/Event_loop
https://en.wikipedia.org/wiki/Futures_and_promises
