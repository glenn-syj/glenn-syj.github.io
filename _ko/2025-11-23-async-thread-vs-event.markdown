---
title: 비동기를 처리하는 두 가지 방식 - 스레드와 이벤트
lang: ko
layout: post
---

## 들어가며

- 이 글은 비동기 처리를 다루는 두 방식인 스레드 기반 방식과 이벤트 루프 기반 방식이 가지는 차이를 다룬다.
- 최종 수정일: 25/11/24

업무에서 FastAPI를 사용하게 되면서 Python의 async/await 기반 이벤트 루프 모델을 경험하게 되었고, 이전에 경험한 Spring MVC 기반의 Thread Pool + CompletableFuture 기반 비동기 처리와 비교할 기회가 생겼다.

Spring MVC는 Thread-Per-Request + Blocking I/O 구조를 사용하기 때문에, 비동기 처리도 본질적으로 스레드 기반 병렬성을 벗어나지 못한다. 요청은 워커 스레드 1개에서 동기적으로 실행되고, JDBC 역시 기본적으로 Blocking I/O 방식이다. 따라서 컨테이너를 Tomcat 대신 Netty로 교체하거나, Spring WebFlux + R2DBC 같은 완전한 non-blocking 스택을 사용하지 않는 다면 비동기의 효과는 결국 스레드를 다른 풀로 분산시키는 수준이라고 이해하고 있다.

반면, FastAPI에서는 async/await 기반 이벤트 루프 비동기 모델을 표면적으로는 쉽게 사용할 수 있지만, 아직 내부 동작 방식은 완전히 이해하지 못했다. 처음에는 psycopg2 같은 blocking DB 드라이버로 구현했으나, 이후 asyncpg로 바꾸어 non-blocking I/O 환경도 직접 경험해보았다.

이 글에서는 FastAPI가 이용하는 이벤트 루프 기반 비동기가 Spring MVC가 이용하는 스레드 기반 비동기와 실제로 어떤 차이가 있는지, 특히 I/O 중심 작업에서의 차이를 더 깊이 살펴보고 비교하고자 한다. 이 과정에서 기본적인 비동기 모델의 차이와 함께, 프레임워크가 가지는 차이도 부수적으로 살펴보고자 한다.

## 비동기 이해하기

### 개념

비동기 프로그래밍은 하나의 작업이 완료되기를 기다리지 않고, 다음 작업을 이어서 실행할 수 있도록 하는 프로그래밍 모델이다. 비동기 프로그래밍에서는 제어 흐름이 비선형적이고, 특정 작업의 완료를 기다리는 동안 스레드가 블로킹되지 않는다. 비동기 모델이 동기 모델과 어떤 차이가 있는지 살펴보면 더욱 이해가 쉽다.

- 제어 흐름의 분리

비동기 모델에서는 작업의 시작과 결과의 처리가 분리되는 것이 특징이다. 동기 모델에서 함수의 호출과 반환이 스택에 쌓인다면, 비동기 모델에서는 작업 지시 후 제어권이 호출부에 반환된다. 이러한 결과는 완료 시점에 비동기 처리 메커니즘을 통해 다루어진다.

- 논블로킹 I/O

동기 모델에서의 I/O 작업이 이루어지면 호출부의 스레드가 대기 상태에 들어간다. 이를 블로킹 I/O라고 부를 수 있다. 반면, 비동기 모델에서는 I/O 작업을 위임하고 바로 제어권을 반환 받는다. 이를 논블로킹 I/O라고 할 수 있다.

비동기 모델이 논블로킹 I/O를 특징으로 가지지만, 기술적으로 논블로킹 I/O 자체가 비동기는 아님에 유의해야한다. 오히려 논블로킹 I/O가 제어 흐름의 분리를 위해서 채택되었다고 보는 것이 더 명확하다. 비동기 처리는 완료 시점에서의 처리 메커니즘까지 포함되는 개념이라고 보면 쉽다.

### 모델 비교: 스레드 vs. 이벤트 루프

## 사례로 보는 비동기 처리

### Spring MVC

### FastAPI

## 사고 실험: 스레드 vs. 이벤트 루프

## 더 나아가기

## References

https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/
https://github.com/python/cpython/blob/e457d60daafe66534283e0f79c81517634408e57/InternalDocs/asyncio.md#L4
