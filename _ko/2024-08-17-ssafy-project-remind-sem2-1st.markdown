---
title: SSAFY 2학기 첫 번째 프로젝트 회고록
lang: ko
layout: post
---

## 들어가며

### Disclaimer

- Last Update: 2024/08/18

- SSAFY는 2학기 첫 프로젝트에 공통 프로젝트라는 이름이 붙였는데요. 이번 글은 해당 과정이 아니라 프로젝트에서 느낀점을 위주로 서술된 회고록입니다.
- SSAFY 과정 내부에서만 알 수 있는 내용은 최대한 서술하지 않았습니다.
- 겪고 얻은 것들과 아쉬운 점에 대해서 기술하는 글입니다.

<br/>

## 겪고 얻다

### 갑작스러운 Spring Security 기존 코드 개선

#### 겪다

- 배경

팀원들의 취업으로 인한 인원 부족으로, 기획 주차에 기존 팀이 해체되었습니다. 상세히 밝히기는 어렵지만, 팀장으로서 (저를 포함한) 남은 인원들이 정말로 필요로 하는 곳에 갈 수 있도록 적극적으로 행동했습니다. 다행히도 좋은 결과를 얻었습니다.

- 업무

기존 팀에서 학습하고 코드를 작성하던 채팅 기능 대신, 새로이 합류한 팀에서는 우선 Spring Security를 이용해 작성된 기존 회원 관리 코드 개선을 맡게 되었습니다.

#### 얻다

- 레거시 코드를 대하는 태도

  레거시 코드를 정의하는 여러 방식이 있지만, 저는 일방적인 대화가 이루어지는 코드로 정의하고 싶습니다. 당연하게도, 언제나 말을 거는 사람은 레거시 코드를 읽는 사람입니다.

  SSAFY나 여타 직업 훈련 기관에서는 쉽게 겪을 수 없지만, 실제로는 빈번한 일 중 하나가 레거시 코드를 개선하는 일이라고 생각합니다. 비록 완전히 갈아엎는 정도는 아니더라도요.

  이번에 맡은 Spring Security는 저도 처음 이용해보기도 하지만, 이전에 작성하시고 SSAFY를 취업 퇴소하신 분께서도 처음 이용해보셨던 프레임워크입니다.

  저는 팀원과 대화하면서, 기존 코드가 일단 인증 및 인가 흐름을 위해 작성되고 설정되었음을 파악하게 되었습니다. 그 덕에 흐름은 유지하되 잘못된 설정 등 미진한 부분만 빠르게 고쳐 회원 기능을 개선할 수 있었습니다.

  기존 코드를 개선하기 전에는 프로젝트 내에서의 중요도를 살펴볼 필요도 있다는 것을 실감할 수 있었습니다.

- Spring Security 5와 6에서의 차이 이해

  정확히는 Spring Security 5버전 이후, 5.4 버전 ~ 6 버전에서의 차이라고 봐도 되겠습니다.

  우선, Spring Security 5.4부터는 기존에 Config 설정을 위해 이용하던 `WebSecurityConfigurerAdapter`가 deprecated되었습니다. 대신 `SecurityFilterChain` 빈을 직접 등록하고 띄우는 방식을 이용합니다.

  또한, 보안 정책을 구성하는 `HttpSecurity`에서 메서드 체이닝이 개선되고, CSRF 및 CORS도 더욱 직관적으로 이용할 수 있도록 변화했습니다.

  인가 과정에서도 `AccessDecisionManager` 및 `AccessDecisionVoter` 대신 `AuthorizationManager`가 이용되면서 유연성이 더욱 강화되었습니다.

### 테스트 코드 작성 with Spring Security

#### 겪다

- 배경

기존 회원 관리 코드를 따라, 개선 후에도 로그인은 Controller이 아니라 Filter 단에서 처리가 되었습니다. 하지만 프론트에서도 Swagger를 이용할 수 없었으며, 채택한 git branch 전략이 github flow 였기도 해 미진하게 나마 테스트 코드를 작성하고자 했습니다. 비록 처음 테스트 코드를 작성해보지만, 좋은 기회로 받아들였습니다.

- 업무

로그인 테스트에서는 MockMVC를 활용해 웹 계층에서의 HTTP 요청과 응답을 모킹하며 로그인 기능을 검증했습니다. 또한, JUnit과 Mockito 프레임워크를 학습하고, 단위 테스트를 위해 `@MockBean` 어노테이션 및 `when().thenReturn()`를 이용할 수 있었습니다.

#### 얻다

- Spring Security 의존성 이해 및 테스트 의의

Spring Security를 적용한 테스트 코드를 작성하며, Spring Security 내부의 의존성을 확실하게 이해할 수 있었습니다. 특히, `AuthenticationManager`가 어떻게 `UserDetailsService`를 이용하는가에 대해서나, `Authentication` 인터페이스의 역할과 전달에 대해서도 말입니다. 이는 제가 Spring Security를 이용하면서 단위 테스트를 진행하려고 노력했기 때문이기도 합니다.

또한, 단위 테스트 코드에서 나오는 결과를 통해 현재 코드에서 어떤 점이 잘못되었는지 살펴볼 수 있는 계기가 되기도 했습니다. 대표적으로 저는 테스트 코드를 작성한 덕에, `CustomUserDetailsService`가 이용되지 않음을 확인할 수 있었습니다.

동시에 테스트 코드는 기존 코드가 얼마나 잘 작성되어 있는지 확인하는 기회라고도 느꼈습니다. 비록 이번에는 크게 경험하지 못했지만, 단위 테스트임에도 너무 많은 의존성을 주입해야하는 경우도 생각해볼 수 있겠습니다. 이런 경우에는 기존 메서드를 나누어야 할 지도 모릅니다.

- 테스트 및 관련 프레임워크 이해

Spring Security에서 어떻게 단위 테스트를 진행할 수 있을까 고민하면서, 통합 테스트와의 차이를 경험할 수 있었습니다. 특히 검색 결과로 나오는 Spring Security를 이용한 테스트는 대부분 통합 테스트였습니다. 심지어는 단위 테스트를 원하는 stackoverflow 질문에도 그냥 통합 테스트를 진행하라는 답변이나 댓글이 달리기도 했었는데요. 통합 테스트가 아니라 단위 테스트를 작성하면서, 저는 확실히 의존성이 단위 테스트에서 차지하는 위치를 알 수 있었습니다.

이는 곧 JUnit이나 Mockito와 같은 프레임워크가 등장하게 된 배경이나, 프레임워크 내에서 자주 쓰이는 메서드들이 왜 중요한지 돌이켜보는 계기가 되기도 했습니다. `verify()`를 통해서 스터빙된 메서드에 대해 검증하거나, `MockMVC`를 활용해 HTTP 요청 및 응답 자체를 모킹하거나, `@MockBean`이나 `@Mock`과 같은 Mockito 어노테이션, JUnit에서 왜 `@Test` 어노테이션을 이용하는지를 알 수 있었습니다. Spring Security와 관련해서도 `@WithMockUser`는 물론, 이에서 나아가 아예 `@WithCustomMockUser` 어노테이션을 직접 작성해보기도 했습니다.

물론 테스트 프레임워크를 처음 이용해보았기에 앞으로 학습해 나가야 할 점이 많습니다. 그럼에도 의존성이 복잡한 Spring Security에 기반한 테스트 코드를 작성하며 Spring Security는 물론 테스트 코드에 관해서도 학습할 수 있는 기회였습니다.

### Redis 및 RabbitMQ 등 외부 서비스 이해

#### 겪다

- 배경

이번 프로젝트에서는 여러 외부 서비스가 사용되었는데요. Redis는 refresh 토큰을 관리하기 위한 사용자 데이터 캐싱이나, 게시글 좋아요나 조회수 등의 쓰기 작업에 대한 배치 처리를 위해 이용했습니다. RabbitMQ는 직접 작성하지는 않았지만, 서비스 내 라이브 코딩 기능에서 응시자와 면접관 사이의 코드 공유 등 실시간 데이터 처리에 쓰였습니다.

비록 프로젝트 일정 상 외부 서비스보다 인프라에 우선 순위를 두긴 했지만, 다양한 외부 서비스의 동작과 설정을 이해해야 배포를 진행할 수 있는 상황이기도 했습니다.

- 업무

우선적으로 Redis에 관한 학습과 조사를 중점을 두고 진행했습니다. 이는 기존 회원 관리 코드에서도 Redis가 쓰였기 때문입니다. 이후 Redis의 캐싱 전략, 지연 처리, 자료 구조, 데이터 영속화와 장애 복구 등을 폭 넓게 학습하며 전략을 세울 수 있었는데요. 그러나 일단 서비스 배포를 우선순위로 두고, 이후 Redis 전략을 심화시켜 보자는 판단에 학습한 내용을 많이 구현하지 못했습니다.

#### 얻다

- Redis와 그 설계 전략에 대한 기본적인 이해

Redis 공식 문서와 기타 참고 자료를 읽으면서, 인메모리 데이터베이스로서의 Redis가 얼마나 많은 방면에서 활용할 수 있는지를 우선 파악했습니다. 특히, 반복적이거나 악의적인 게시글 조회나 좋아요를 통해 DB에 쓰기가 자주 발생하면 부하가 발생할 수 있다는 점이 문제적이었습니다. 따라서 Redis에만 반영하고, 특정 시간 간격을 두고 배치 처리를 통해 DB에 쓰기 연산을 진행하도록 설계했습니다. 게다가 게시글 조회수나 좋아요 데이터는 서비스의 핵심 기능이 아니면서도 정확한 반영이 중요하지 않았으므로, Redis에서 지원하는 Hyperloglog 자료구조를 이용했습니다.

또한, refresh 토큰을 관리함에 있어서도 Redis를 이용하여 빠른 접근 속도와 추후의 스케일링을 고려할 수 있었습니다. 이는 인증 토큰이 사용자 간에는 공유되지 않는 데이터이자, 상태를 유지할 필요가 적으며, TTL(Time-to-Live)를 통해 쉽게 관리할 수 있다는 장점을 살린 전략이었습니다. 특히 안전하게 로그아웃해 토큰 재사용을 막으면서도, 특정 토큰을 차단할 필요가 없다고 판단했기에 Refresh Token Rotation 전략을 이용했습니다.

추후 아쉬운 점을 이야기하면서 말하겠지만, 사실 '기본적인 이해'라고 쓴 것은 우선순위에 밀려 메모리 관리나 여타 전략을 시행해보지 못했던 까닭이 큽니다. 하지만 확실히 얻은 것은, 어떠한 기능을 작성하거나 데이터를 다룰 때 중요한 것은 기술 자체가 아니라 서비스 측면에서 바라보아야 한다는 점이겠습니다.

### Infra 담당하기: Jenkins, CI/CD, AWS EC2, Docker, NginX

#### 겪다

- 배경

프로젝트 마무리 2주를 남기고, 프론트엔드와 백엔드 모두에서 핵심 기능들이 완성되어 감에 따라
