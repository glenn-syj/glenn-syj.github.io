---
title: 파이프로 살펴보는 동시성 - Xv6와 CSP Thread
lang: ko
layout: post
---

## 들어가며

- 이 글은 MIT에서 제공하는 과목인 Operating System Engineering(6.S081)을 학습하며, 파이프가 동시성 개념에서 어떤 역할을 하는지 느낀 바를 정리한 내용입니다.
- 학습용으로 사용되는 xv6에서 primes 과제를 수행하며, 각 소수마다 별도의 프로세스를 만들고 파이프를 통해 숫자를 전달하는 구조를 구현했습니다. (MIT 과제이므로 코드는 따로 공개하지 않았습니다.)

## 파이프 이해하기

### 파이프의 개념 및 역할

파이프(pipe)는 **프로세스 간 통신(Inter-Process Communication, IPC)**를 다루는 한 방식입니다. 파이프는 한 프로세스의 출력을 다른 프로세스의 입력으로 직접 연결하여 데이터를 전달합니다. 따라서 하나의 파이프는 한쪽 끝을 입력(읽기)으로 삼고 다른 쪽 끝을 출력(쓰기)으로 삼습니다.

파이프를 통해 전달되는 데이터는 바이트 스트림(byte stream) 형태로 이용됩니다. 따라서 파이프를 통해서 다양한 종류의 데이터를 유연하고 효율적으로 처리할 수 있습니다. 파이프는 데이터를 변환할 필요가 없으며, 어떤 종류의 데이터든 바이트로 표현될 수 있기 때문입니다. 대신 데이터를 읽는 프로세스는 데이터의 특성에 맞게 데이터를 해석해야 합니다.

### 실생활으로 파이프 이해하기

파이프라는 이름에서 드러나듯이, 실제로 삶과 밀접한 파이프를 떠올려보면 이해하기 쉽습니다. 대표적인 예시로 정수기에서 뜨거운 물을 마시고자 하는 예시가 있습니다. 여기에서 바이트 스트림은 '물'이라고 생각하면 쉽습니다.

첫 시작을 정수 과정 이후라고 생각하겠습니다.

1. 파이프
   - 출발: 외부 수도관
   - 끝: 필터가 있는 급수관 입구
   - 바이트 스트림: 물
2. 프로세스: 정수 필터
   - 정수 필터는 파이프로부터 물(바이트 스트림)을 받아서 물의 불순물을 제거함
   - 여기에서 정수 필터는 물의 불순물 수준을 파악하고, 걸러내는 역할 수행
3. 파이프
   - 시작: 정수된 물이 저장된 공간
   - 끝: 온수 가열 장치 입구
   - 바이트 스트림: 물
4. 프로세스: 온수 가열 장치
   - 온수 가열 장치는 파이프로부터 물(바이트 스트림)을 받아서 뜨거운 물로 변환
   - 여기에서 온수 가열 장치는 물의 온도를 해석하고, 특정 온도까지 가열시키는 역할 수행
5. 파이프
   - 시작: 온수 탱크 출수 대기 지점 (온수 가열 장치 이후에 물이 나오는 지점)
   - 끝: 출수구
   - 바이트 스트림: 물

위 예시에서 파이프는 단순히 '물'이라는 바이트 스트림을 전달하는 역할만 할 뿐, 어떠한 해석이나 변환도 거치지 않음에 주목할 필요가 있습니다. 파이프는 단방향으로 데이터를 전송하고, 해석하고 변환하는 역할은 프로세스가 다룹니다. 정수 필터와 온수 가열 장치처럼요.

## 동시성 - CSP 모델 이해하기

### 동시성 살펴보기

> concurrency refers to the ability of a system to execute multiple tasks through simultaneous execution or time-sharing (context switching), sharing resources and managing interactions.
> https://en.wikipedia.org/wiki/Concurrency_(computer_science)

위키피디아에서 정의하는 동시성(concurrency)의 핵심적인 특성을 살펴보겠습니다.

1. 시스템이 여러 작업을 실행할 수 있는 능력
   - 시스템이 여러 독립적이나 상호 연관된 작업(프로세스, 스레드, 함수 호출 등)을 다룰 수 있음
2. 동시적인 실행이나 시분할(컨텍스트 스위칭)
   - 동시적인 실행: 여러 개의 프로세서나 장치에서 여러 작업이 말 그대로 동시에 실행됨 (병렬성과 연관)
   - 시분할(컨텍스트 스위칭): 단일 CPU 코어에서 각 작업을 아주 짧은 시간 동안 번갈아가며 실행함
3. 자원 공유
   - 여러 작업이 메모리, 파일, 네트워크 연결 등의 시스템 자원을 공유함
4. 상호작용 관리
   - 자원을 공유하거나 서로 영향을 미치는 작업 사이의 데이터 불일치, 경합, 교착 등의 문제를 조정하고 관리함

### CSP 모델

CSP (Communicating Sequential Processes) 모델은 토니 호어(Tony Hoare)가 개발한 동시성 모델인데요. CSP는 시스템의 상호작용을 수학적으로 분석하기 위한 프로세스 대수(Process Calculi, Process Algebra) 방법론의 일부입니다. 2021-xv6-labs 에서는 [Bell Labs and CSP Threads](https://swtch.com/~rsc/thread/)라는 글을 통해서 호어의 CSP를 간략하게 소개합니다.

#### 순차 프로세스와 통신

CSP에서 시스템은 여러 개의 독립적인 '순차 프로세스'로 구성됩니다. 여기에서 프로세스는 외부의 영향을 받지 않는 자체적인 상태를 가지고, 순차적으로 프로세스 내부의 작업을 실행합니다.

그런데 순차 프로세스는 분명히 "외부의 영향을 받지 않는다"고 했는데, 어떻게 서로에게 영향을 미치는 시스템을 구성할 수 있을까요? 이는 채널을 이용해서 순차 프로세스가 통신을 진행하기 때문입니다.

CSP는 기본적으로 Unbuffered Channel을 이용하는데요. Unbuffered Channel은 데이터를 임시로 저장할 버퍼가 없기에 메시지의 송수신 과정에서 같은 시점에 채널에서 만나야만(rendezvous) 동기화가 진행됩니다. 여기에서 메시지를 보내는 프로세스는 메시지를 보낸 후 수신자가 해당 메시지를 실제로 받을 때까지 블로킹됩니다. 마찬가지로 메시지를 받는 프로세스도 보낼 메시지가 도착할 때까지 블로킹됩니다.

그 결과로 별도의 락이나 세마포어와 같은 복잡한 동기화 메커니즘 없이도 경합 상태를 방지하는 셈입니다.

#### 고수준 추상화

동기화와 경합 상태를 관리하기 위해서 이용되는 락, 뮤텍스, 세마포어 등의 공유 메모리(shared memory) 모델은 동일한 메모리 공간 안에서 명시적인 관리를 필요로 합니다. 반면, 메시지 전달 기반의 채널은 서로 독립된 메모리 공간에서 채널을 통해서만 메시지를 주고 받습니다.

따라서 프로그래머는 채널이라는 고수준의 추상화 인터페이스를 통해서 프로세스의 로직과 채널을 통한 메시지 흐름에만 신경을 쓰면 됩니다. 공유 메모리 모델 기반의 방식이 자원 중심의 "무엇을 보호할 것인가?"에 초점을 둔다면, CSP의 채널은 통신 중심의 "데이터가 어떻게 흐를 것인가?"에 집중하는 셈입니다.
