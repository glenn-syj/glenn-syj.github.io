---
title: PNPM과 Next.js standalone을 이용한 빌드 및 배포
lang: ko
layout: post
---

## 들어가며

- TFT 기반 라이벌리 서비스 Rivals를 개발 및 배포하는 과정에서 PNPM을 이용하며 겪었던 문제와 원인을 파악하는 글입니다.
- 최종 수정: 25/06/05

## 패키지 매니저와 PNPM

저는 최근 Rivals라는 Riot TFT(전략적 팀 전투) 기반 라이벌리 제공 서비스를 개발하고 있습니다. 이 프로젝트에서는 npm이나 yarn보다 빌드 속도 상 우위에 있다는 이야기를 많이 들어 이번에는 pnpm을 패키지 매니저로 선정했습니다.

저는 pnpm 패키지 매니저 기반 next.js에서의 standalone 방식을 이용할 때, `server.js` 실행 시 모듈 임포트와 관련된 에러를 마주했었는데요. 배포에 우선 순위를 두어 일단 `.npmrc` 파일에 `node-linker=hoisted` 옵션을 추가하는 방식으로 해결했었습니다.

그러나 이러한 해결책이 과연 진정한 해결책일까요? 위 옵션을 이용한다면 pnpm만이 가지는 장점이 사라지는 게 아닐까요? 이번 글은 이러한 의심에서 시작해봅니다. 가장 먼저, 패키지 매니저에서부터 살펴보겠습니다.

### 패키지 매니저의 개념과 기능

패키지 매니저는 개발에 필요한 라이브러리나 프레임워크의 의존성을 관리하는 도구입니다. 특히, 명시된 의존성 정보를 바탕으로 패키지를 설치하고, 소스코드에서는 명시된 특정 버전의 라이브러리를 이용할 수 있도록 합니다.

대표적으로 Javascript에서는 npm, yarn, pnpm이 패키지 매니저로 활약하고 있습니다. Java에서의 gradle도 패키지 매니징과 함께 빌드 매니징을 지원하고 있구요. Hombrew나 apt 역시 패키지 매니저라 볼 수 있습니다. 이번 글에서는 Node.js 생태계 내에서의 패키지 매니저를 다룹니다.

패키지 매니저의 기본적인 기능은 무엇일까요? 이는 "만약 패키지 매니저가 없었다면 어떻게 의존성 관리를 진행해야할까?"라는 질문에서 시작하면 좋습니다. MDN Web Docs에서는 패키지 매니저를 쓰지 않는 경우에 관해 이야기합니다.

```
1. 정확한 패키지의 자바스크립트 파일을 모두 찾는다.
2. 해당 패키지에 알려진 취약점이 없는지 살펴본다.
3. 패키지를 다운로드하고 프로젝트 내의 정확한 경로에 넣는다.
4. 어플리케이션에서 패키지를 코드에 넣는다.
5. 1-4를 패키지의 모든 하위 의존성에 대해 반복한다.
6. 패키지를 삭제하고 싶다면 다시 모든 파일을 삭제한다.
```

즉, 패키지 매니저는 패키지 설치부터 삭제 등의 관리, 취약점 확인 등의 보안까지 전반적으로 담당한다고 말할 수 있겠습니다.

### PNPM의 주특징

지난 단락에서 `node-linker=hoisted` 옵션에 대해서 언급했습니다. 이 옵션을 본다면 먼저 `node-linker`란 무엇일까, 하는 의문이 들기 마련입니다. 듣자하니 노드(node)를 링크(link)해주는 옵션 같습니다. 이 옵션을 이해하기 위해서는 먼저 PNPM 패키지 매니저의 동작 방식을 알아야 합니다.

PNPM은 Perforamant NPM의 약어입니다. PNPM이 다른 패키지 매니저와 가장 대비되는 특성은 콘텐츠 주소 지정 가능 저장소(Content-Addressable Store)와 링크 방식입니다.

#### 수평적 효율성 - 콘텐츠 주소 지정 가능 저장소

PNPM으로 설치되는 모든 패키지 파일은 시스템 내의 전역 단일 저장소에 저장되는데요. 이는 콘텐츠 주소 지정 가능한(Content-Addressable) 방식으로 관리됩니다. 파일의 이름이나 위치가 아닌 파일 내용의 해시값을 기반으로 파일이 저장되고 식별된다는 뜻입니다. 아래는 [pnpm.io](pnpm.io)에서 가져온 이미지입니다.

![Content-addressable store](../assets/images/250605+pnpm-content-addressable-store.svg)

npm에서는 의존성 패키지 A를 이용하는 100개의 프로젝트를 위해서 100번 복사되어 이용됩니다. 이는 곧 패키지 A에 변화가 생길 때 npm은 100개 전체에 대해서 클론을 진행해야함을 의미합니다. 하지만 pnpm은 변경된 파일 하나에 대해서만 전역적으로 저장하면 끝입니다.

저는 이를 두고 '수평적 효율성'이라고 말하고 싶은데요. 시스템 내에서 여러 다른 프로젝트가 동일한 패키지를 필요로 할 때, 해당 파일 콘텐츠를 전역 저장소에서 단 한 번만 저장한 것으로 이용하기 때문입니다. 또한, 의존성 간에 이용하는 파일이 동일한 경우도 저장소에 한 번만 저장되기에 중복을 제거할 수 있습니다. 이러한 방식으로 프로젝트 수나 의존성 수가 증가하는 '수평적인 확장'에서 pnpm은 디스크 공간을 절약합니다.

#### 수직적 효율성 - 하드 링크와 심볼릭 링크

pnpm은 `node_modules` 디렉토리를 이용하는 방식에서도 근본적인 차이가 있습니다.. `pnpm install` 명령이 실행되면 의존성 관리는 다음과 같이 이루어집니다.

**전역 콘텐츠 주소 지정 저장소에서 하드 링크 생성:** pnpm은 먼저 시스템 내 전역 저장소에 있는 패키지 파일들에 대해 해당 프로젝트의 `node_modules/.pnpm` 디렉토리 내에 **하드 링크**를 생성합니다.

하드 링크는 원본 파일과 동일한 inode를 가리키므로, 실제 디스크 공간을 추가로 차지하지 않으면서 파일에 직접 접근하는 것과 같은 효과를 냅니다. 이 `.pnpm` 디렉토리 안에는 프로젝트가 필요로 하는 모든 의존성 패키지(직접 의존성 및 하위 의존성)가 각각의 폴더 구조로 정리되어 존재합니다.

**프로젝트 `node_modules`에 심볼릭 링크 생성:** 그 다음, 프로젝트의 `package.json`에 명시된 **직접 의존성**에 대해서만 `node_modules` 디렉토리 최상단에 `node_modules/.pnpm` 내의 실제 패키지 폴더로 연결되는 **심볼릭 링크**를 생성합니다. 하위 의존성은 해당 의존성을 필요로 하는 상위 패키지의 `node_modules` 내부에 심볼릭 링크로 연결됩니다.

### 왜 PNPM은 더 빠를까?

## Next.js와 Standalone 옵션

## PNPM의 심볼릭 링크와 node_modules

## 노드 링커 Hoisted만이 정답일까?

## 나가며

## Refereneces

https://toss.tech/article/lightning-talks-package-manager

https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Client-side_tools/Package_management
