---
title: 프로그래밍을 이루는 세 가지 축에 대한 개인적 이해
lang: ko
layout: post
---

## 들어가며

- 이 글은 지금, 스스로 프로그래밍을 바라보는 관점을 정리하기 위해 작성한 글이다. 학술적 타당성이나 새로움보다는 관점의 정립에 목적이 있다.
- 최종 수정일: 25/12/06

회사에서 RAG를 다루기도 하고, 개인적으로도 [Feather](https://github.com/glenn-syj/feather)라는 검색 엔진 및 경량 데이터베이스를 구축하는 과정에서 '프로그래밍이란 무엇일까'라는 질문을 다시 생각하게 되었다. 기술을 익히고 프로젝트를 진행하는 과정은 결국 근본적인 질문과 맞닿아 있기 때문이다.또한, 지금 내가 바라보는 프로그래밍의 기반이 무엇인지에 대한 고민도 중요할 것이다.

컴퓨터 과학을 공부하다보면, 운영체제나 데이터베이스와 같이 개별 과목이 가지는 경계 안에서 사고하는 경우가 잦다. 학문적 분류는 분명히 운영체제, 데이터베이스, 네트워크 등과 같이 잘게 나뉘어 있다. 하지만 실제 프로그래밍은 그 경계의 교차점에서 발생하는 문제를 다루는 활동이 아닐까?

이러한 이해를 위해서는 학문적 구분이 아닌, 프로그래밍을 구성하는 더 근본적인 축을 찾는 시도가 필요하다. 따라서 나는 그 축을 '정보'라는 관점에서 바라보려고 한다. 컴퓨터 과학의 분과에서 한 발 물러나 생각해보자.

프로그래밍을 '정보 흐름을 설계하고 최적화하는 활동'으로 이해하면 어떨까? 정보 시스템(Information System)에서의 도구로서 프로그래밍이 갖는 역할이라기보다는, 프로그래밍 자체에 초점을 두는 관점으로 말이다. 그렇다면 이 '정보 흐름'을 이루는 것이 바로 프로그래밍을 구성하는 축이 될 것이다.

본론으로 들어가기 전에, 이러한 축은 앞으로의 학습을 진행하기 위한 개인적인 관점 정립임을 다시 한 번 명시한다.

## 프로그래밍을 이루는 세 가지 축

프로그래밍을 이루는 세 가지 축을 통신, 저장, 검색이라고 생각해보자. 간단한 웹 어플리케이션을 예시로 삼아도 좋겠다.

우리는 흔히 웹 어플리케이션에 대해서 프론트엔드, 백엔드, 데이터베이스라는 식으로 시스템을 나누어 설명하고는 한다. 이런 구분은 구현 단계에서의 책임 분리이지, 프로그래밍을 구성하는 근본 원리는 아니다. 프론트엔드는 사용자와 상호작용하며 서버로부터 정보를 받아오고, 백엔드는 필요한 연산을 처리해 다시 정보를 돌려주며, 데이터베이스는 그 정보를 적절히 저장하고 검색할 수 있게 한다. 이렇게 바라보면 서로 다른 역할처럼 보였던 요소들이 사실은 하나의 정보 흐름 속에 통합된다.

그런데 이와 같은 흐름은 데이터베이스 내부에서도 마찬가지로 존재한다. 데이터베이스는 단순히 저장 기능에만 국한된 데이터를 보관하는 저장소가 아니다. 내부적으로도 페이지를 읽어오고(통신), 디스크에 기록하며(저장), 필요한 데이터를 찾아내는(검색) 정보 흐름을 가지고 있다.

운영체제도 마찬가지다. 운영체제는 메모리나 파일 시스템을 통해 정보를 저장하고, 프로세스 간 통신(IPC)이나 시스템 콜을 통해 정보를 전달하며, 페이지 테이블이나 파일 디렉토리를 탐색하는 방식으로 필요한 정보를 찾아낸다.

즉, 프로그래밍을 특정 기술 스택이나 계층에 종속된 활동이 아니라, 정보를 저장하고, 옮기고, 찾아내는 일의 반복과 최적화로 바라 볼 수 있다. 물론, 규모가 커짐에 따라 증가하는 복잡성을 처리하는 것은 별개의 이야기다. 연산은 통신, 저장, 검색을 다룬 후에 이야기하겠다.

### 통신, 저장, 검색

#### 통신 (Communication)

통신은 정보가 한 지점에서 다른 지점으로 이동하는 과정이다.

흔히 통신이라고 하면 HTTP 요청이나 메시지 큐 같은 네트워크 인프라를 떠올린다. 하지만 사실 프로그래밍 언어의 함수 호출부터 운영체제의 프로세스 간 통신, 서버 간 RPC, 이벤트 스트림까지 모두 “정보를 전달한다”는 동일한 패턴을 공유한다.

#### 저장 (Storage)

저장은 정보가 보존되는 과정이다.

저장이라고 하면 보통 디스크나 데이터베이스처럼 영속적인 저장매체를 떠올리지만, 저장은 훨씬 넓은 개념이라고 생각한다. 프로그램은 실행되는 동안 끊임없이 상태(state)를 유지해야 하고, 그 상태는 형태만 다를 뿐 모두 저장된 정보이다.

#### 검색 (Retrieval)

검색은 필요한 정보를 선택하고 꺼내는 과정이다.

배열을 선형적으로 탐색하는 것부터 RDBMS의 인덱스, 그래프 탐색, 심지어 캐시 히트 여부 판단까지 모두 정보를 찾는 행위다. 규모와 맥락이 다를 뿐, 결국 프로그램은 필요한 정보가 어디에 있는지 검색하며 동작한다.

### 예시: 주소 결정 프로토콜(ARP)

위 세 축에 대한 예시로 ARP를 들어보고자 한다. ARP는 흔히 네트워크라는 과목 속에서 다뤄지지만, 통신-저장-검색이라는 구조를 잘 나타내는 사례다.

먼저, 운영체제는 패킷을 특정 IP 주소로 보내기 위해 해당 IP에 대응하는 MAC 주소를 검색한다. 이때 가장 먼저 ARP 테이블을 확인한다.

ARP 테이블은 IP와 MAC 주소를 매핑시키는 일종의 캐시 테이블이다. 테이블에 원하는 항목이 이미 저장되어 있으면, 운영체제는 저장된 정보를 그대로 꺼내어 사용한다.

하지만 테이블에 기록이 없다면, 운영체제는 외부에서 정보를 얻어와야 한다. 이때 이루어지는 것이 ARP 요청과 응답이라는 통신 과정이다. 네트워크에 IP 주소에 대한 MAC 주소 요청을 브로드캐스트하면, 그 장치가 자신의 MAC 주소를 유니캐스트 응답으로 알려준다. 운영체제는 이 정보를 다시 ARP 테이블에 저장하고 이용한다.

이 흐름을 따라가 보면 ARP는 주소 변환 기능을 넘어선다. 정보가 찾아지고, 전달되고, 보존되는 과정이 작은 규모에서 어떻게 반복되는지가 잘 드러나는 까닭이다. 이런 의미에서 ARP 예시는 정보 흐름을 이해하는 하나의 작은 프랙탈처럼 볼 수 있다.

## 세 축의 개인적 의미

이러한 관점은 내가 프로그래밍을 이해하고 학습하는 데 도움이 될 것이라고 믿는다. 왜냐하면 기술마다 새로운 개념과 구조가 등장하는 것처럼 보이지만, 그 기반에는 따라가다 보면 늘 정보를 어떻게 전달하고(통신), 보존하며(저장), 다시 찾아 사용할 것인가(검색)라는 동일한 문제로 귀결되기 때문이다.

그래서 이러한 구조를 틀로 삼아 앞으로의 프로그래밍을 이해하고자 한다. 그렇다면 새로운 기술을 배울 때도 통신, 저장, 검색을 중심으로 나누어 빠르게 맥락을 잡을 수 있다. 또한, 복잡해 보이는 시스템도 결국 이 세 가지 과정의 조합으로 추상화해 이해할 수 있다. 실제 문제를 해결하는 과정에서도 세 축에서 시작해 문제를 파악할 수 있다.

### 축 간의 관계

특히 흥미로운 점은 하나의 시스템이나 프로그램이 특정 축에 더 강하게 특화되거나, 혹은 하나의 축을 최적화하기 위해 다른 축과의 관계를 재설계한다는 점이다. 시스템을 이러한 시각에서 보면 기술의 목적을 더 명확히 파악할 수 있다.

예를 들어, 데이터베이스 시스템은 겉으로는 저장을 중심에 둔 기술처럼 보인다. 하지만 데이터베이스는 검색을 위해 저장 구조를 적극적으로 재배치한다. 인덱스 구조나 정렬된 페이지 레이아웃은 모두 검색을 위한 저장 방식이다. 즉, 저장이라는 축이 검색이라는 축을 위해 최적화되는 셈이다.

반대로 Kafka나 RabbitMQ 같은 메시징 시스템은 통신을 주목적으로 하지만, 높은 신뢰성을 위해 내부적으로는 로그를 지속적으로 저장한다. 이들은 통신을 강화하기 위해 저장 축을 재활용하는 구조다. 통신을 안정적으로 만들기 위해 저장을 도입하는 셈이므로, 두 축이 서로 얽혀 목적을 보완한다.

또 다른 예로, 검색 엔진은 이름만 보면 검색 중심의 시스템으로 여겨진다. 하지만 대규모 사전 구조, 역색인, 벡터 스토어 등 다양한 저장 구조 위에서 작동한다. 검색을 효율적으로 하기 위해 저장에 몸을 맡기고 있다.

이처럼 시스템마다 어느 축에 더 많은 힘을 실을지, 혹은 어떤 축을 희생해 다른 축을 강화할지가 다르다. 이 관계는 기술적 선택이나 설계상의 트레이드오프를 이해하는 데 중요한 기준점이 된다.

### 개인 프로젝트 Feather 경험

이러한 관점은 내가 Feather를 개발하는 과정에서도 자연스럽게 드러났다. 경량 데이터베이스로서 정보를 저장하고 다시 찾아 쓰기 위한 구조를 바닥부터 설계했던 프로젝트다. (현재 진행중이다.) 처음에는 Lucene을 더욱 가볍게 구현해보자는 학습 목적이었지만, 구현을 진행할수록 Feather 내부에서 이루어지는 대부분의 일이 결국 통신–저장–검색이라는 세 축을 중심으로 조직되어 있다고 느꼈다.

예를 들어, 문서를 인덱싱하는 과정은 겉으로 보기에는 단순히 텍스트를 처리하는 작업처럼 보인다. 하지만 실제로는 검색을 효율적으로 만들기 위해 텍스트를 토큰 단위로 분해하고, 그 토큰들을 사전 구조에 저장하며, 역색인을 구축하는 일련의 데이터 변환 과정이다. 이 과정 전부가 검색을 위해 저장을 재구성하는 것이다.

또한, 바이너리 파일 포맷(.dic, .post, .doc, .meta 등)을 설계하면서는 저장이 어떻게 검색과 연관되는지 알 수 있었다. 사전을 어떻게 구성할 것인가, 문서 ID를 어떤 방식으로 저장할 것인가, 포스팅 리스트를 어떤 구조로 정렬하고 압축할 것인가 같은 결정들은 모두 저장 방식을 통한 검색 최적화를 고민하는 과정이었다. 즉, 저장이라는 축이 보관 수단을 넘어 검색이라는 축을 위해 적극적으로 최적화되는 것이다.

재밌게도, Feather를 만들며 바닥부터 한 층씩 쌓아 올리는 경험을 통해 검색 엔진 그 이상을 배웠다. 시스템이 정보를 어떻게 전달하고, 보존하고, 찾아내는지를 살펴볼수록, 세 축이 실제 구현에서 가지는 역할을 체감할 수 있었다.

## 연산은 어디로?

그런데 컴퓨터라는 이름에서 드러나듯이, 연산의 중요성도 빼놓을 수 없다. 실제 프로그래밍에서는 어떤 형태로든 계산이 이루어진다. 더하기 연산, 조건 판단, 문자열 조작, 데이터 정렬 및 압축 등 모든 활동이 연산이다.

나는 연산을 독립된 축이나 더욱 근본적인 기반으로 두기보다는 정보의 흐름을 조직하고 최적화하기 위해 수행되는 변환 과정이라고 이해하고자 한다. 즉, 연산은 통신, 저장, 검색을 가능하게 하거나 더 효율적으로 만들기 위해 정보의 형태를 바꾸는 역할을 한다.

예를 들어 정렬 연산을 보자. 정렬은 그 자체로 목적이 있는 것이 아니라, 이후의 검색을 빠르게 하기 위해 데이터를 재배치하는 과정이다. 해시 함수 계산은 저장이나 검색을 일정한 시간 안에 수행하기 위해 정보를 압축하고 재구성하는 활동이다. 암호화는 정보를 안전하게 통신하기 위해 필요한 형태로 변환하는 것이다.

이렇게 보면 연산은 정보와 분리된 실체가 아니라, 정보를 다음 단계의 처리에 적합한 형태로 만드는 변환이다. 연산은 새로운 정보를 창출하기도 하고, 노이즈를 제거하거나 구조를 재배열하기도 하며, 목적에 맞게 정보를 압축하거나 확장하기도 한다. 하지만 이러한 모든 활동은 어디까지나 더 큰 흐름의 일부로서 수행된다.

그래서 나는 연산을 프로그래밍의 중심 원리나 축으로 보기보다는, 세 축 사이에서 작동하는 정보 조작의 메커니즘으로 이해하고 있다. 정보가 흐르기 위해서는 적절히 다듬어져야 한다. 따라서 연산은 구조라기보다는 정보를 발생시키는 작동 방식이라고 생각한다. 통신을 위해서는 한 지점에서 다른 지점에 맞게 변환되어야 하고, 저장을 위해서도 저장소가 원하는 틀에 맞게 재구성되어야 한다. 검색을 위해서도 정보는 식별될 수 있도록 구분되어 가공된 채로 있어야 한다.

## 다시 컴퓨터 과학으로
