---
title: OOP 세계에서 AOP 이해하기
lang: ko
layout: post
---

## 들어가며

- Spring Transaction에서 `@Transactional`의 동작을 파악하며, AOP 프록시 객체를 이용한다는 것을 알게 되었습니다.
- 부트캠프에서 Spring 프레임워크를 학습하며 AOP에 대해 처음 배울 당시, 공식문서에서의 보완적이라는 설명과 달리 OOP와 AOP가 서로 상반되는 패러다임이 아닌가? 하는 의문이 들었습니다.
- 따라서 이번 글에서는 OOP 세계에서 Spring AOP를 더욱 잘 이해하는 방식에 대해서 이야기해보고자 합니다.

## OOP 세계

### OOP를 바라보는 흔한 시선

우리는 객체 지향 프로그래밍(Object Oriented Programming)을 어떻게 이해해야 할까요? 저는 단순히 OOP를 그 특성으로만 이해하고 싶지는 않습니다.

특히 OOP에 있어 객체를 중심으로 한 세계의 모델링이라는 설명, 속성으로서의 데이터와 행위로서의 메서드라는 설명, 캡슐화-상속-다형성이라는 세 축을 중심으로 한 설명은 언뜻 말이 되지만 부족한 듯 보였습니다.

이는 모두 객체 지향 프로그래밍의 특성을 설명하는 것이지, 객체 지향 프로그래밍의 특성을 핵심적으로 관통하는 원리에는 닿지 않는다고 느끼기 때문입니다.

특히, 객체 지향 프로그래밍 역시 다른 패러다임과 마찬가지로 하늘에서 갑자기 뚝 떨어진 것은 아닐 것이며, 절차형 패러다임 속에서도 객체 지향 프로그래밍의 씨앗은 존재했을 것이기 때문입니다.

이러한 오해는 모두 객체(Object)라는 말에 과하게 집중할 때 드러납니다.

### 객체 혹은 행위자

객체 지향 프로그래밍을 바라보는 흔한 시선에서 객체는 수동적인 존재로 남습니다. 여기에서 수동적이라고 함은, 객체가 가지는 능동성과 객체 간 네트워크보다는 객체를 구성하는 방식과 객체 자체를 중심으로 객체가 이해된다는 의미입니다.

객체가 세계의 모델링이라는 모방론적 설명은 객체를 현실 세계에 지나치게 일 대 일 대응 시키고 있으며, 데이터와 메서드로 객체 지향 프로그래밍을 바라보는 설명은 객체를 지나치게 단순한 컨테이너 같은 존재로 보이게 합니다. 또한, 캡슐화-상속-다형성을 중심으로 한 설명은 세 특징이 곧 객체 지향 프로그래밍의 필요 충분 조건으로 여겨지게 하는 위험이 있습니다.

이러한 시선에서는 부분적으로 객체(Object)라는 용어가 내포하는 수동성이 영향을 미쳤을 수도 있다는 생각이 듭니다. 그리고 마찬가지로, 프로그래머가 능동적으로 시스템과 코드를 구성한다는 관점에서 객체 지향 프로그래밍을 이해하게 되면서 구현이 중심이 되며 객체의 수동성이 부각되었을 수 있겠습니다.

그렇다면 앨런 케이(Alan Kay)는 훗날 객체 대신 행위자(Actor)라고 부르는 게 나았다는 후회가 이해됩니다. 저는 앨런 케이가 진정 강조하고 싶었던 것은 원칙에 맞게 코드로 빚어낸 객체 하나하나가 아니라, 행위자로서 소통하고 대응하는 객체의 네트워크이자 그 행위 방식이라고 생각합니다.

즉, OOP에 대한 이해는 객체가 존재하는 방식이나 형태가 아니라, 객체가 행위하는(acting) 방식과 형태를 살펴보는 일에서 시작되어야 합니다.

### 기본 단위: 행위

이제 OOP 세계에서의 기본 단위로서 행위(action)를 살펴보고자 합니다. 여기에서의 행위는 모듈의 내부 속성이나 행동(behavior)을 의미하는 것이 아닙니다.

저는 행위를 행위자 간 네트워크 내에서 다른 행위자에게 영향을 미치는 것으로 이해합니다. 여기에서 앨런 케이가 자신이 OOP에서 중요하게 여기는 것은 오직 메시징, 상태-프로세스의 지역적 유지(local retention)와 보호 및 은닉(protection and hiding), 그리고 모든 것의 극단적인 늦은 바인딩(extreme late-binding)이라고 했던 것의 의미를 다시 생각해볼 수 있습니다.

#### 메시징

메시징의 가장 중요한 의의는 메시지는 명령이 아니라는 점입니다. 메시지는 행위자가 다른 행위자에게 요청하는 것이지, 명령을 하달하는 일과는 다릅니다.

메시지는 요청적이고, 의도를 전달한 뒤 처리는 맡기고, 결합도가 낮으며, 수신자가 자율적입니다. 반면, 명령은 지시적이고, 명시된 수행 방법을 따르고, 결합도가 높고, 수신자가 수동적으로 남아있습니다.

이러한 방식에서 제어 흐름은 앨런 케이가 참고한 생물학적 세포나 개별 연산 단위와 같이 중앙 제어 시스템에서 하달되는 것이 아니라, 행위자 간의 네트워크로 구성됩니다.

#### 상태-프로세스의 지역적 유지, 보호 및 은닉

앨런 케이의 용어를 그대로 가져온 것은 캡슐화의 더욱 근본적인 측면을 강조하고 싶기 때문입니다. 이는 캡슐화라는 단어 자체에서 보호와 은닉에 집중하면 객체가 데이터와 메서드가 합쳐진 무언가라고 여겨지는 오해를 불러 일으킨다고 생각하기 때문인데요. 특히, 캡슐화는 정보 은닉과 접근 제어와 같은 기술적 구현의 일종이라고 보는 것이 더 적절한데도 말입니다.

반면, 상태-프로세스의 지역적 유지는 더욱 근본적으로 객체의 책임과 자율성을 논하는 용어로 보입니다. 여기에서 중요한 것은 각 객체가 독립적으로 책임지는 상태와 프로세스를 모두 가지고 있고, 오직 메시지를 통해서만 상호작용한다는 점입니다.
